## Goal 

Endorsements are included in a block's header. They are created by randomly selected endorsers chosen amon the stakers (including the block creator) to endorse the block's parent in the same thread. The block's total fee and reward are split between the block creator, the endorsers, and the creator of the endorsed block.

With that mechanism it becomes harder to gain control of the network (you now have to control `endorsement_count + 1` draw to gain control over one block). This mechanism also reward stakers more frequently, reducing the need for pooling and thus increasing decentralization.

```rust

pub struct BlockHeaderContent {
    pub endorsements: Vec<Endorsement>,
    ..
}
```

## Endorsement structure

An endorsement is defined as follows: 
```rust
pub struct Endorsement {
    pub content: EndorsementContent,
    pub signature: Signature,
}

pub struct EndorsementContent {
    /// Public key of the endorser.
    pub sender_public_key: PublicKey,
    /// slot of endorsed block (= parent in the same thread) (can be different than the previous slot in the same thread)
    pub slot: Slot,
    /// endorsement index inside the block
    pub index: u32,
    /// hash of endorsed block (= parent in the same thread)
    pub endorsed_block: BlockId,
}
```

The endorser is selected to create an endorsement for the block of a specific (slot, endorsement_index). To be included in a specific block the endorsement should endorse the parent of the block in the same thread, and slot has to match that parent's slot. The signature is produced by signing the header_content with the sender_public_key.

## Endorsement production

Endorsements are automatically produced every time block db changed, if the slot hasn't already been endorsed, if it is at most one period before the last slot, and  if a staking address of the node has been selected. Created endorsements are sent to the endorsement pool.

## Endorsement propagation

Once an endorsement is created by consensus module, it is sent to the endorsement pool, where it is stored waiting for a request from the consensus module. It is then sent to the protocol module and to every node for which we don't know if the node already has this endorsement. On the other hand, when receiving an endorsement from the network, the protocol module saves which node sent it, checks the signature and send it to the endorsement pool.

The endorsement pool is pruned if it reaches a max size and when new slots become final.

## Endorsement integration

When creating a block the consensus module asks the pool module for endorsements specifying:
- target_slot: the slot of the parent in the same thread of the block that is being created
- parent: the BlockId of the parent in the same thread
- creators: the ordered addresses that were selected to create endorsements for that slot

The pool module responds with a vec of endorsement that is endorsement_count long or less, as some endorsements may be missing. That vec is ordered by endorsement index and when there are endorsement_count endorsements, that index should match the vec index.

## Reward computation

A block reward R (including constant reward and fees) is distributed as follows:

- `1/(1 + config.endorsement_count)` goes to the block creator
- For each included endorsement:
    - `1/(3*(1 + config.endorsement_count))` goes to the block creator
    - `1/(3*(1 + config.endorsement_count))` goes to the endorsed block's creator
    - `1/(3*(1 + config.endorsement_count))` goes to the creator of the endorsement

Lossless rounding is done in favor of the block creator

### Example

Given :
- addresses A, B, C in thread 0
- block 1 at slot(1,0) created by A
- operation O with a fee of 30 coins
- block 2 at slot(2,0)
    - created by B
    - with operation O
    - with following endorsements
        - 1 endorsement by A
        - 2 endorsement by B
        - 3 endorsement by C
    - constant block reward of 70 coins

Let `share = 1 / (3*(1+endorsement_count)) = 1/(3*(1+6)) = 1/21 = 0.0476`.
Here we will use two digits precision.

The total reward generated by block 2 is 100 = 30 + 70 coins.
- the part that goes to A is :
    - `reward * endorsement_count * share = 100 * 6 * 1/21 = 28.57` because A created the endorsed block
    - `+ reward * nb_created_endorsements * share = 100 * 1 * 1/21 = 4.76` because A created 1 endorsement
    - `= 33.33`
- the part that goes to C is :
    - `reward * nb_created_endorsements * share = 100 * 3 * 1/21 = 14.28` because C created 3 endorsements
- the part that goes to B is :
    - `reward * 1/(1 + endorsement_count) = 100 * 1/(1+6) = 14.28` because B created the block
    - `+ reward * nb_created_endorsements * share = 100 *2 * 1/21 = 9.52` because B created 2 endorsements
    - `+ reward * endorsement_count * share = 100 * 6 * 1/21 = 28.57` because B included 6 endorsements
    - `+ rounding`
    - `= reward - other_stakers_parts`
    - `= 52.39`


## Fitness

The fitness of a block is `(1 + number_of_included_endorsements)`.